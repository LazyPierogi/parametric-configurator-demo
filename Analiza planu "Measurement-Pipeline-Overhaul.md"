# Analiza planu "Measurement-Pipeline-Overhaul.md"

# Feedback 1

PrzeanalizowaÅ‚em dokument i porÃ³wnaÅ‚em go z istniejÄ…cÄ… architekturÄ…. Oto moja ocena:

## âœ… Mocne strony planu

### 1. **Jedno ÅºrÃ³dÅ‚o prawdy (Etap 1)**
- **DoskonaÅ‚e rozwiÄ…zanie**: eliminacja chaotycznego wielokrotnego pomiaru (meas#1/2/3) to kluczowa poprawa
- SpÃ³jne z [NEW-FLOW-PLAN.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/NEW-FLOW-PLAN.md:0:0-0:0) Milestone C
- Measurement cache z kluczem `signature::polyHash` zapewnia stabilnoÅ›Ä‡

### 2. **Fallback polygon â†’ maska (Etap 2)**
- **Bardzo dobry kierunek**: obecny system ma problem z `mask:missing_or_rejected` â†’ peÅ‚na Å›ciana
- UÅ¼ywanie `fracPoly` jako fallbacku jest sensowne i deterministyczne
- Zachowuje mask-first approach tam gdzie dziaÅ‚a, polygon-based tam gdzie maska zawodzi

### 3. **Struktura etapowa**
- Separacja measurement â†’ geometry â†’ provider â†’ UX to prawidÅ‚owa kolejnoÅ›Ä‡
- KaÅ¼dy etap ma jasne dependency i ASCII-diagramy

## âš ï¸ Ryzyka i potencjalne problemy

### 1. **Etap 3: Provider strategy zbyt ambitna**

```text
Problem: Plan zakÅ‚ada 3 rÃ³wnolegÅ‚e providery (noreref/Qwen/VLM) + hybrid fallback
```

**Konflikt z NEW-FLOW-PLAN.md:**
- [NEW-FLOW-PLAN.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/NEW-FLOW-PLAN.md:0:0-0:0) (lines 36-44) juÅ¼ ustala: **Qwen = canonical wall-first**, VLM = polygon specialists
- Obecna implementacja juÅ¼ ma Qwen wallÃ—bbox scaling (line 67-69 NEW-FLOW-PLAN)
- **Recommendation**: Etap 3 powinien byÄ‡ prostszy â€” zaimplementowaÄ‡ TYLKO przeÅ‚Ä…cznik `AI1_PROVIDER=qwen|googleai|openai`, bez rÃ³wnolegÅ‚ego uruchamiania wszystkich

### 2. **Etap 1: Brak pomiaru w /estimate moÅ¼e zablokowaÄ‡ UX**

```text
Plan (line 67-68): "/estimate upload TYLKO segmentuje, nie robi /api/measure"
```

**Problem**:
- UÅ¼ytkownik musi narysowaÄ‡ polygon ZANIM zobaczy wymiary
- Co jeÅ›li polygon jest Åºle narysowany? BÄ™dzie musiaÅ‚ wracaÄ‡ do /estimate
- W obecnej implementacji mamy "measure while drawing" dla lepszego feedback loop

**Recommendation**: 
- ZachowaÄ‡ measurement w `/estimate` po narysowaniu polygona (jak jest teraz)
- Ale **nie uruchamiaÄ‡** measurement bez polygona (to siÄ™ zgadza z planem)

### 3. **Etap 4: UX gating moÅ¼e byÄ‡ zbyt restrykcyjny**

```text
Plan (line 217-219): Modal otwieramy DOPIERO gdy measurement ORAZ segmentacja ready
```

**Problem**:
- Segmentacja moÅ¼e trwaÄ‡ dÅ‚ugo (especially HF fallback)
- Blokowanie uÅ¼ytkownika na measurement+segmentation zwiÄ™ksza opÃ³Åºnienie
- [NEW-FLOW-PLAN.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/NEW-FLOW-PLAN.md:0:0-0:0) line 93-94 mÃ³wi: "segmentation runs in parallel and does not block interaction"

**Recommendation**:
- Pokazuj modal z wymiarami gdy measurement ready
- Segmentacja niech trwa w tle, ale disable CTA dopÃ³ki nie skoÅ„czy
- Komunikuj jasno: "Analyzing wall... You can review dimensions while we work"

### 4. **Etap 5: Benchmark moÅ¼e byÄ‡ przedwczesny**

```text
Plan (line 253-294): Benchmark z â‰¥20 zdjÄ™Ä‡, porÃ³wnanie noreref vs Qwen
```

**Problem**:
- W [NEW-FLOW-PLAN.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/NEW-FLOW-PLAN.md:0:0-0:0) (line 161-165) jest juÅ¼ accuracy mitigation strategy
- Benchmark powinien przyjÅ›Ä‡ PRZED Milestone D (rollout), nie jako osobny etap
- Ground truth collection to osobny effort (patrz `900-Accuracy-Quick-Wins.md`)

**Recommendation**:
- PoÅ‚Ä…cz Etap 5 z Milestone D acceptance criteria
- UÅ¼yj istniejÄ…cych test cases z `measure-debug-*` folders jako baseline

## ğŸ¯ Zmodyfikowana kolejnoÅ›Ä‡ (moja propozycja)

### **Etap 1: Jedno ÅºrÃ³dÅ‚o prawdy** âœ… BEZ ZMIAN
- `/estimate`: segment + polygon + measure (w tej kolejnoÅ›ci)
- `/configure`: uÅ¼ywa `flow.measurement`, nie remeasure

### **Etap 2: Polygon fallback** âœ… BEZ ZMIAN  
- `fracPoly` fallback gdy maska zawodzi
- ZÅ‚agodzone progi `MASK_HEIGHT_RATIO_MIN/MAX`

### **Etap 3 (UPROSZCZONY): Provider toggle**
```text
/api/measure(photoDataUri, polygon, provider?)
  â”œâ”€â–º if provider === 'qwen' (default dla new flow):
  â”‚      base = QwenOppositeWall(photoDataUri)
  â”‚      meas = measureWithFallback({ base, polygon })
  â”‚
  â””â”€â–º else (googleai/openai):
         meas = GenkitVLM(photoDataUri, polygon)
```

**NIE implementuj:**
- ~~hybrid fallback (Qwen â†’ VLM)~~ â€” to zostawiÄ‡ na Milestone D tuning
- ~~noreref jako rÃ³wnolegÅ‚y path~~ â€” to jest experimental branch, nie prod

### **Etap 4 (ZMIÄ˜KCZONE GATING): Progressive UX**
```text
/estimate
  â”œâ”€â–º measurement ready â†’ show modal + dimensions
  â”œâ”€â–º segmentation pending â†’ CTA disabled + "Analyzing wall..."
  â””â”€â–º both ready â†’ CTA enabled
```

### **Etap 5: Measurement Diagnostics integration**
- Measurement Diagnostics juÅ¼ istnieje (`apps/web/lib/measurement-observer.ts`)
- Dodaj eksport CSV z Etapu 1-4 wynikÃ³w
- To bÄ™dzie input do pÃ³Åºniejszego benchmarku

### **Milestone D (wczeÅ›niej Etap 5): Benchmark & Rollout**
- Ground truth collection
- PorÃ³wnanie accuracy przed/po
- Go/no-go review

## ğŸ“‹ Konkretne rekomendacje zmian w dokumencie

### Do edycji w [Measurement-Pipeline-Overhaul.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/Measurement-Pipeline-Overhaul.md:0:0-0:0):

1. **Etap 1, line 67**: ZmieÅ„ na:
   ```
   - pomiar odpala siÄ™ w `startPolygonMeasurement()` z gotowym polygonem
     (user rysuje polygon â†’ measure button â†’ /api/measure)
   ```

2. **Etap 3**: UsuÅ„ sekcjÄ™ 3a (noreref), zostaw tylko:
   - 3a: Qwen as default (wallÃ—bbox)
   - 3b: VLM providers (googleai/openai) as alternatives
   - Hybrid fallback â†’ defer to post-Milestone B

3. **Etap 4, line 217**: ZmieÅ„ na:
   ```
   - modal z wymiarami otwieramy gdy:
     - measurement gotowy (polygon narysowany i zmierzony)
   - CTA "PrzejdÅº do konfiguratora":
     - disabled dopÃ³ki segmentacja trwa
   ```

4. **Etap 5**: ZmieÅ„ tytuÅ‚ na "Diagnostics & Logging", przenieÅ› benchmark do:
   ```
   ## 6. Milestone D â€” Benchmark & Rollout
   (zawartoÅ›Ä‡ obecnego Etapu 5 + acceptance criteria)
   ```

## âœ¨ Podsumowanie

**Czy to najlepsze rozwiÄ…zanie?** 

ğŸ‘ **TAK dla EtapÃ³w 1-2** â€” to sÄ… fundamentalne poprawki architektury

âš ï¸ **CZÄ˜ÅšCIOWO dla EtapÃ³w 3-5** â€” zbyt ambitne, konfliktujÄ… z istniejÄ…cym [NEW-FLOW-PLAN.md](cci:7://file:///Users/mario/Repo/Curtain%20Wizard/project%20planning/NEW-FLOW-PLAN.md:0:0-0:0)

**Co zrobiÄ‡:**
1. WdrÃ³Å¼ Etapy 1-2 jako priorytet (to sÄ… quick wins)
2. UproÅ›Ä‡ Etap 3 do prostego provider switch
3. ZÅ‚agodÅº Etap 4 gating dla lepszego UX
4. PrzenieÅ› benchmark do Milestone D (po implementacji EtapÃ³w 1-4)

**Bottom line**: Plan jest solidny ale needs simplification. Zbyt wiele moving parts na raz = ryzyko. Lepiej iteracyjnie: implement core (1-2) â†’ validate â†’ extend (3-4) â†’ benchmark (D).

# Feedback 2

NajwaÅ¼niejsze uwagi (wg wagi):

project planning/Measurement-Pipeline-Overhaul.md:165-172,183-197: Plan zakÅ‚ada Qwen jako prodâ€‘default, co kÅ‚Ã³ci siÄ™ z aktualnym kontraktem AI #1 (Genkit, default Gemini 2.x + OpenAI o3 fallback) i wymaganiem obsÅ‚ugi obu flow. ProponujÄ™: zostawiÄ‡ AI1_PROVIDER domyÅ›lnie na Genkit/Gemini, Qwen za flagÄ…/ENV z peÅ‚nym fallbackiem do Genkit, a noreref jako eksperyment; inaczej ryzykujemy rozjazd z resztÄ… AIâ€‘stacku i utratÄ™ pokrycia legacy flow.

project planning/Measurement-Pipeline-Overhaul.md (lines 69-74): Cache signature::polyHash nie uwzglÄ™dnia providera, wersji algorytmu ani trybu (legacy/new). Przy przeÅ‚Ä…czaniu provider dostaniemy nie ten pomiar. Dopisz do klucza: provider, wersjÄ™ modelu/algorytmu, wersjÄ™ planu (np. v2), oraz flagÄ™ flow.

project planning/Measurement-Pipeline-Overhaul.md (lines 82-92) vs 121-136: Nie jest jasno zdefiniowane, czy meas#P to wymiar Å›ciany czy juÅ¼ przeskalowany na polygon. JeÅ›li API z polygonem zwraca juÅ¼ curtainâ€‘height, a geometria ponownie mnoÅ¼y przez fracWall/fracPoly, dostaniemy podwÃ³jnÄ… skalÄ™. Trzeba spiÄ…Ä‡ kontrakt: API zwraca wall cm, geometria mnoÅ¼y â†’ albo API zwraca curtain cm, geometria ich nie skaluje.

project planning/Measurement-Pipeline-Overhaul.md (lines 109-116): CURTAIN_BOX_HEIGHT_SOURCE='mask' musi byÄ‡ per newâ€‘flow i za flagÄ… (NEXT_PUBLIC_CONFIGURE_FLOW), Å¼eby nie zepsuÄ‡ legacy. Plan nie nazywa guardÃ³w ani rollbacku (np. env switch).

project planning/Measurement-Pipeline-Overhaul.md (lines 216-244): Gating modala/CTA na segmentacjÄ™ moÅ¼e zablokowaÄ‡ usera przy dÅ‚ugich/nieudanych segmentacjach. Przyda siÄ™ timeout + jasny fallback (np. retry/skip), Å¼eby nie utknÄ…Ä‡ w loaderze; plan tego nie opisuje.

project planning/Measurement-Pipeline-Overhaul.md (lines 262-289): ZbiÃ³r testowy â‰¥20 to maÅ‚o i moÅ¼e nie pokryÄ‡ wariantÃ³w (rÃ³Å¼ne EXIF, dystans, gÅ‚Ä™bia). Cel <10% bÄ™dzie sÅ‚abo uwiarygodniony; warto celowaÄ‡ w 40â€“50 zdjÄ™Ä‡, zrÃ³wnowaÅ¼one EXIF i rÃ³Å¼ne typy okien, plus eksport peÅ‚nych logÃ³w (provider, prompt, EXIF, polygon, mask status).

Dodatkowe pytania/do doprecyzowania:

Jak traktujemy brak polygona przy wejÅ›ciu prosto na /configure w newâ€‘flow? Czy debugowy /api/measure moÅ¼e wtedy awaryjnie uzupeÅ‚niÄ‡ baseCm bez Å‚amania â€1 foto + 1 polygonâ€?
Czy measureWithFallback (Qwen) ma korzystaÄ‡ z zapisanej maski, czy zawsze pracuje bez maski? Warto to ujednoliciÄ‡ z Etapem 2, Å¼eby diagnostyki byÅ‚y spÃ³jne.
Czy Measurement Diagnostics (ostatnie 40 odpowiedzi) zapisze provider/model/cacheâ€‘hit, by benchmark i prod miaÅ‚y wspÃ³lne metadane?
Kierunek jest sÅ‚uszny (1 ÅºrÃ³dÅ‚o prawdy, mask+poly fallback, benchmarking), ale wymaga powyÅ¼szych korekt, Å¼eby nie rozjechaÄ‡ siÄ™ z obecnym kontraktem AI1 i nie wprowadziÄ‡ regresji w legacy flow. Next steps: ustal kontrakt meas#P, rozszerz klucz cache, dodaÄ‡ flagi/provider defaults zgodne z Genkit, oraz dopisaÄ‡ timeout/fallback UX dla segmentacji.

# Feedback 3

Dobra, jedziemy po kolei â€“ co ma sens, co bym zostawiÅ‚ â€na potemâ€, a co bym uproÅ›ciÅ‚, zanim przekombinujesz.

BÄ™dÄ™ siÄ™ odnosiÅ‚ do etapÃ³w z Measurement-Pipeline-Overhaul.md i ogÃ³lnego planu z NEW-FLOW-PLAN.md.

â¸»

1. â€Jedno ÅºrÃ³dÅ‚o prawdyâ€ dla pomiaru (Etap 1) â€“ âœ… RÃ“B

To:

1 foto + 1 polygon â‡’ 1 kanoniczny pomiar cm
/estimate robi tylko segmentacjÄ™, pomiar dopiero w startPolygonMeasurement() z polygonem, a /configure NIE odpala kolejnego /api/measure w prod.

To jest absolutnie sÅ‚uszne. Teraz masz klasycznÄ… â€fabrykÄ™ pomiarÃ³wâ€ (meas#1/2/3) i brak jednego ÅºrÃ³dÅ‚a prawdy, co mÅ›ci siÄ™ wszÄ™dzie: debug, UX, pricing. ï¿¼

Moja opinia:
  â€¢ Ten etap to must-have, zanim dotkniesz czegokolwiek z maskami, EXIF, providerami.
  â€¢ Bardzo dobry pomysÅ‚, Å¼eby:
  â€¢ /estimate â†’ segmentuje i czeka na polygon,
  â€¢ /api/measure(photo, polygon) â†’ jedyny kanoniczny measurement,
  â€¢ /configure â†’ tylko konsumuje flow.measurement, debugowe /api/measure max. za flaga.

Jedyne, czego bym pilnowaÅ‚:
  â€¢ W logach wszÄ™dzie loguj measurementId/signature::polyHash, Å¼ebyÅ› mÃ³gÅ‚ Å›ledziÄ‡ jeden measurement end-to-end.
  â€¢ Nie dawaj w prod Å¼adnych â€ukrytychâ€ re-measure po stronie /configure, nawet jako â€sprytny fallbackâ€ â€“ to znowu rozmyje ÅºrÃ³dÅ‚o prawdy.

â¸»

2. Polygon + maska jako ÅºrÃ³dÅ‚o wysokoÅ›ci (Etap 2) â€“ âœ… ALE OSTROÅ»NIE Z PRIORYTETEM MASKI

Plan:
  â€¢ CURTAIN_BOX_HEIGHT_SOURCE='mask' dla nowego flow.
  â€¢ MaskÄ… prÃ³bujesz doprecyzowaÄ‡ wallTop/wallBottom, a jak maska jest sÅ‚aba â†’ fallback na bbox / polygon.

To jest logiczne, ale:
  1.  Maska jako â€doprecyzowanieâ€, nie â€prawda objawionaâ€
Przy Twoim use-case (zasÅ‚ony na pÅ‚askiej Å›cianie) polygon juÅ¼ daje sensownÄ… geometriÄ™. Maska ma:
  â€¢ duÅ¼y potencjaÅ‚ na edge-caseâ€™y (okna, kwiatki, lampy),
  â€¢ noise z segmentation modeli,
  â€¢ inny lifecycle (cache, timeouty, backend fallback). ï¿¼
Ja bym traktowaÅ‚ maskÄ™ JAKO:
  â€¢ soft hint: â€jeÅ›li speÅ‚nia zestaw twardych warunkÃ³w (coverage, span, ratio) â†’ popraw wysokoÅ›Ä‡â€,
  â€¢ ale nigdy nie pozwalaÅ‚ jej skrÃ³ciÄ‡ wysokoÅ›ci do idiotycznych wartoÅ›ci bez silnych guardÃ³w.
  2.  To, co masz w planie, jest sensowne:
  â€¢ Ratio guard MASK_HEIGHT_RATIO_MIN/MAX + fallback do peÅ‚nego bboxa â†’ bardzo dobra obrona przed zjechanÄ… maskÄ…. ï¿¼
  â€¢ Fallback mask:fallback_poly_only kiedy maska pada â†’ super, dopÃ³ki to jest jasno logowane w Measurement Diagnostics.
  3.  Co bym uproÅ›ciÅ‚ / odÅ‚oÅ¼yÅ‚ na pÃ³Åºniej:
  â€¢ Nie przesadzaÅ‚bym z liczbÄ… heurystyk na maskÄ™ na tym etapie.
Najpierw:
  â€¢ 1 prosty zestaw reguÅ‚ (span, min coverage, ratio do bboxa),
  â€¢ solidne logowanie kiedy maska jest odrzucona,
  â€¢ benchmark czy maska realnie poprawia medianÄ™ / p90.
  â€¢ JeÅ›li po benchmarku okaÅ¼e siÄ™, Å¼e maska poprawia <2â€“3% przypadkÃ³w, a psuje kolejne 5â€“10%, to bym jÄ… zostawiÅ‚ gÅ‚Ã³wnie do wizualizacji, a nie do kluczowej geometrii.

PodsumowujÄ…c Etap 2:
Tak â€“ rÃ³b, ale psychicznie traktuj maskÄ™ jako bonus, a nie filar systemu.

â¸»

3. Strategia providerÃ³w (noreref + Qwen + VLM) â€“ âœ… KIERUNEK DOBRY, ZBYT WIELE OPCJI NA RAZ

Masz Å‚adnie rozpisane:
  â€¢ Qwen jako kanoniczny estimator Å›ciany + bbox-scaling dla polygona. ï¿¼
  â€¢ noreref jako lokalny no-reference z EXIF + segmentacja.
  â€¢ OpenAI/Gemini jako VLM fallback/polygon-specialist.

To architektonicznie ma sens, ale:

3.1. Co jest bardzo sensowne
  1.  Qwen wall-first + geometric rectangle
  â€¢ Idealnie wpisuje siÄ™ w Twoje zaÅ‚oÅ¼enia: on mierzy skalÄ™ Å›ciany, Ty przeliczasz polygon na uÅ‚amek Å›ciany. ï¿¼
  â€¢ To jest stabilne i Å‚atwe do debugowania: cm Å›ciany, bbox fraction, prosta matematyka.
  2.  noreref jako eksperymentalny
  â€¢ Bardzo dobrze, Å¼e sam sobie piszesz: â€uÅ¼ywaÄ‡ w trybie eksperymentalnym, dopÃ³ki benchmark nie pokaÅ¼e <10% bÅ‚Ä™duâ€. ï¿¼
  â€¢ No-reference jest fajne na papierze, ale w realu jest mega wraÅ¼liwe na EXIF, FOV, kÄ…t, dystans â€“ dobrze, Å¼e nie chcesz na tym oprzeÄ‡ prod.
  3.  measureWithFallback() + confidence gating
  â€¢ PomysÅ‚, Å¼eby provider zwracaÅ‚ confidence, a Ty masz centralne fallbacki â†’ bardzo dobry wzorzec. ï¿¼

3.2. Co moim zdaniem nie ma sensu na tym etapie
  1.  Zbyt duÅ¼o aktywnych providerÃ³w naraz w prod
JeÅ›li realnie chcesz dowieÅºÄ‡ stabilny produkt, to:
  â€¢ Prod:
  â€¢ 1 gÅ‚Ã³wny provider â€“ Qwen (lub inny VLM), wall-first.
  â€¢ Dev/QA:
  â€¢ noreref, ewentualnie Gemini/OpenAI jako porÃ³wnanie.
Inaczej wyhodujesz sobie matrioszkÄ™ bugÃ³w:
â€u tego usera measurement przyszedÅ‚ z Qwen, u tamtego z noreref, tu fallback na VLM, tam mask-fallbackâ€â€¦ i debug zamienia siÄ™ w bÃ³l istnienia.
  2.  Cross-provider fallbacks w runtime
PomysÅ‚: â€jeÅ›li Qwen polygon fail â†’ odpal VLM X, a potem geometry fallbackâ€ jest fajny akademicko, ale:
  â€¢ komplikuje debug,
  â€¢ zwiÄ™ksza latency/spend,
  â€¢ wprowadza duÅ¼o niewidocznej dla usera magii.
Ja bym na tÄ™ chwilÄ™:
  â€¢ nie robiÅ‚ cross-providerÃ³w w prod,
  â€¢ trzymaÅ‚ je tylko w benchmarku offline (Etap 5).

3.3. Jak bym to uproÅ›ciÅ‚

Stack v1 (prod-ready):
  â€¢ Provider domyÅ›lny: Qwen wall-first.
  â€¢ Geometria: polygon bbox fractions + mask jako soft hint (Etap 2).
  â€¢ noreref: tylko w panelu debug / benchmark CLI.
  â€¢ Å»adne cross-provider fallbacki w runtime.
  â€¢ measureWithFallback() uÅ¼ywane do:
  â€¢ fallbacku geometrycznego (Å›ciana â†’ bbox),
  â€¢ wewnÄ…trz jednego providera (np. confidence < X â†’ uÅ¼yj samego wall Ã— bbox).

â¸»

4. UX i gating (Etap 4) â€“ âœ… Z MAÅYM ALE

Plan:
  â€¢ Modal z wymiarami dopiero gdy:
  â€¢ pomiar gotowy i
  â€¢ segmentacja gotowa. ï¿¼

I CTA â€PrzejdÅº do konfiguratoraâ€ zablokowane do czasu aÅ¼ oba bÄ™dÄ… gotowe.

Co ma sens:
  â€¢ To spina siÄ™ z tym, Å¼e /configure potrzebuje i maski, i measurementu, Å¼eby nie wejÅ›Ä‡ w â€pÃ³Å‚Å¼ywyâ€ stan.
  â€¢ To rÃ³wnieÅ¼ pomaga uniknÄ…Ä‡ magii, Å¼e uÅ¼ytkownik widzi inne liczby w /estimate i inne w /configure.

Moje â€aleâ€:
  â€¢ JeÅ›li segmentacja bywa zauwaÅ¼alnie wolniejsza niÅ¼ measurement:
  â€¢ RozwaÅ¼yÅ‚bym:
  â€¢ wymiary moÅ¼esz pokazaÄ‡ od razu po measurement,
  â€¢ ale CTA â€Dalejâ€ odblokowujesz dopiero, gdy segmentacja dowiezie (wyjaÅ›niajÄ…c w UI â€Å‚adowanie inteligentnego podglÄ…du zasÅ‚onâ€ itd.).
  â€¢ Daje to wraÅ¼enie, Å¼e system reaguje szybciej, zamiast â€nic siÄ™ nie dzieje, bo czekamy na wszystkoâ€.

To nie jest bÅ‚Ä…d, tylko kwestia wraÅ¼eÅ„ z UX. JeÅ›li czasy inferencji sÄ… OK, TwÃ³j pierwotny plan teÅ¼ przejdzie.

â¸»

5. Benchmark i QA (Etap 5) â€“ âœ… MUST-HAVE, ZROBIONE DOBRZE

PomysÅ‚:
  â€¢ ZbiÃ³r testowy â‰¥20 fot z ground truth + polygon,
  â€¢ odpalanie /api/measure z rÃ³Å¼nymi providerami i liczenie median/p90 bÅ‚Ä™du,
  â€¢ wybÃ³r domyÅ›lnego providera na podstawie liczb, nie przeczucia.

To jest dokÅ‚adnie to, co powinieneÅ› robiÄ‡. Jedyne, co dorzucÄ™:
  â€¢ Cel typu â€<10% bÅ‚Ä™du dla 85â€“90% zdjÄ™Ä‡â€ â€“ masz juÅ¼ w planie, super. ï¿¼
  â€¢ Zadbaj, Å¼eby dataset miaÅ‚:
  â€¢ rÃ³Å¼ne ogniskowe,
  â€¢ rÃ³Å¼ne wysokoÅ›ci zawieszenia zasÅ‚ony,
  â€¢ rÃ³Å¼ne perspektywy (lekko z boku, lekko z gÃ³ry, etc.),
  â€¢ fotki â€brudneâ€ (roÅ›liny, krzesÅ‚a, grzejnik).

Bez tego wytrenujesz pipeline na idealnych zdjÄ™ciach i zderzysz siÄ™ ze Å›cianÄ… w realu (haha).

â¸»

6. Curtain-first flow z NEW-FLOW-PLAN.md â€“ âœ… TRAFIONE ZAÅOÅ»ENIA

GÅ‚Ã³wne zasady:
  â€¢ â€Single geometryâ€ â€“ polygon usera jest jedynÄ… prawdÄ… o curtain boxie w caÅ‚ym kodzie. ï¿¼
  â€¢ Najpierw dowieÅºÄ‡ MeasurementService (Milestone A), dopiero potem UI-churn.
  â€¢ Feature flag NEXT_PUBLIC_CONFIGURE_FLOW=legacy|new.
  â€¢ /configure nie startuje nowego flow bez peÅ‚nego pakietu {mask, polygon, measurement}.

To wszystko jest bardzo zdrowe produktowo i technicznie.
To, co juÅ¼ masz zrobione (Qwen wallâ†’rect scaling + geometry guardy + Diagnostics) jest spÃ³jne z tym planem.

Jedyne potencjalne â€overkillâ€ na teraz:
  â€¢ Bardzo rozbudowany risk register + analityka + multi-flow offline restore â€“ to jest Å›wietne, ale jeÅ›li masz ograniczony czas, priorytetyzuj:
  1.  Jedno ÅºrÃ³dÅ‚o prawdy (Etap 1),
  2.  Stabilny provider (Qwen) + prosty geometry fallback (Etap 3),
  3.  Benchmark (Etap 5),
  4.  Dopiero potem finezje UX/analityczne.

â¸»

7. Co bym zrobiÅ‚ w jakiej kolejnoÅ›ci (konkretny plan)

JeÅ›li miaÅ‚bym to poukÅ‚adaÄ‡ dla Ciebie praktycznie:
  1.  Etap 1 â€“ jedyny measurement
  â€¢ WyÅ‚Ä…czyÄ‡ pomiar w startAnalysis().
  â€¢ UpewniÄ‡ siÄ™, Å¼e /configure nigdy nie odpala /api/measure, jeÅ›li ma flow.measurement.
  2.  Provider stack v1:
  â€¢ AI1_PROVIDER=qwen jako domyÅ›lny.
  â€¢ noreref tylko w debug i benchmark CLI.
  â€¢ W measureWithFallback() tylko:
  â€¢ wall â†’ bbox geometria,
  â€¢ confidence-fallback w obrÄ™bie jednego providera.
  3.  Maska (Etap 2) â€“ wersja minimum:
  â€¢ Proste ratio guard + span guard,
  â€¢ fallback do polygon bbox,
  â€¢ logowanie ostrzeÅ¼eÅ„ w Diagnostics.
  4.  UX gating (Etap 4):
  â€¢ Modal po measurement,
  â€¢ CTA â€Dalejâ€ odblokowane, gdy segmentacja gotowa (i jasny loader, czemu czekamy).
  5.  Benchmark (Etap 5):
  â€¢ 20+ fot, pomiary vs Qwen, noreref,
  â€¢ na tej podstawie potwierdziÄ‡, Å¼e Qwen zostaje main.

â¸»

